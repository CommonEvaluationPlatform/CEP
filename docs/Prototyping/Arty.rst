Running a Design on Arty
========================

Arty100T Instructions
----------------------

The default Xilinx Arty 100T harness uses a TSI-over-UART adapter to bringup the FPGA.
A user can connect to the Arty 100T target using a special ``uart_tsi`` program that opens a UART TTY.
The interface for the ``uart_tsi`` program provides unique functionality that is useful for bringing up test chips.

To build the design, run:

.. code-block:: shell

		cd fpga/
		make SUB_PROJECT=arty100t

To build the UART-based frontend server, run:

.. code-block:: shell

		cd generators/testchipip/uart_tsi
		make

After programming the bitstream, and connecting the Arty's UART to a host PC via the USB cable, the ``uart_tsi`` program can be run to interact with the target.

Running a program:

.. code-block:: shell

		./uart_tsi +tty=/dev/ttyUSBX dhrystone.riscv

Probe an address on the target system:

.. code-block:: shell

		./uart_tsi +tty=/dev/ttyUSBX +init_read=0x10040 none

Write some address before running a program:

.. code-block:: shell

		./uart_tsi +tty=/dev/ttyUSBX +init_write=0x80000000:0xdeadbeef none

Self-check that binary loading proceeded correctly:

.. code-block:: shell

		./uart_tsi +tty=/dev/ttyUSBX +selfcheck dhrystone.riscv

Run a design at a higher baud rate than default (For example, if ``CONFIG=UART921600RocketArty100TConfig`` were built):

.. code-block:: shell

		./uart_tsi +tty=/dev/ttyUSBX +baudrate=921600 dhrystone.riscv


Arty35T Legacy Instructions
---------------------------

The default Xilinx Arty 35T harness is setup to have JTAG available over the board's PMOD pins, and UART available over its FTDI serial USB adapter. The pin mappings for JTAG signals are identical to those described in the `SiFive Freedom E310 Arty 35T Getting Started Guide <https://static.dev.sifive.com/SiFive-E310-arty-gettingstarted-v1.0.6.pdf>`__.
The JTAG interface allows a user to connect to the core via OpenOCD, run bare-metal applications, and debug these applications with gdb. UART allows a user to communicate with the core over a USB connection and serial console running on a PC.
To extend this design, a user may create their own Chipyard configuration and add the ``WithArtyTweaks`` located in ``fpga/src/main/scala/arty/Configs.scala``.
Adding this config. fragment will enable and connect the JTAG and UART interfaces to your Chipyard design.

.. literalinclude:: ../../fpga/src/main/scala/arty/Configs.scala
    :language: scala
    :start-after: DOC include start: AbstractArty and Rocket
    :end-before: DOC include end: AbstractArty and Rocket

Future peripherals to be supported include the Arty 35T SPI Flash EEPROM, and I2C/PWM/SPI over the Arty 35T GPIO pins. These peripherals are available as part of sifive-blocks.

Brief Implementation Description and Guidance for Adding/Changing Xilinx Collateral
-----------------------------------------------------------------------------------

Like the VCU118, the basis for the Arty 35T design is the creation of a special test harness that connects the external IO (which exist as Xilinx IP blackboxes) to the Chipyard design.
This is done with the ``ArtyTestHarness`` in the basic default Arty 35T target. However, unlike the ``VCU118TestHarness``, the ``ArtyTestHarness`` uses no ``Overlays``, and instead directly connects chip top IO to the ports of the external IO blackboxes, using functions such as ``IOBUF`` provided by ``fpga-shells``.
Unlike the VCU118 and other more complicated test harnesses, the Arty 35T Vivado collateral is not generated by ``Overlays``, but rather are a static collection of ``create_ip`` and ``set_properties`` statements located in the files within ``fpga/fpga-shells/xilinx/arty/tcl`` and ``fpga/fpga-shells/xilinx/arty/constraints``.
If the user wishes to re-map FPGA package pins to different harness-level IO, this may be changed within ``fpga/fpga-shells/xilinx/arty/constraints/arty-master.xdc``. The addition of new Xilinx IP blocks may be done in ``fpga-shells/xilinx/arty/tcl/ip.tcl``, mapped to harness-level IOs in ``arty-master.xdc``, and wired through from the test harness to the chip top using ``HarnessBinders`` and ``IOBinders``.
Examples of a simple ``IOBinder`` and ``HarnessBinder`` for routing signals (in this case the debug and JTAG resets) from the core to the test harness are the ``WithResetPassthrough`` and ``WithArtyResetHarnessBinder``.
